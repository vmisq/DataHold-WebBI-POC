table_catalog	table_schema	table_name	view_definition	check_option	is_updatable	is_insertable_into	is_trigger_updatable	is_trigger_deletable	is_trigger_insertable_into
memory	public_url	aa2	CREATE VIEW public_url.aa2 AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	aaa3	CREATE VIEW public_url.aaa3 AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	aaaaa	CREATE VIEW public_url.aaaaa AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	aabbcc	CREATE VIEW public_url.aabbcc AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	aabbcc11	CREATE VIEW public_url.aabbcc11 AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	abc	CREATE VIEW public_url.abc AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	abc1	CREATE VIEW public_url.abc1 AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	access_code_password_recovery_code	CREATE VIEW public_url.access_code_password_recovery_code AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009159412/access-code-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	ateste	CREATE VIEW public_url.ateste AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	email23	CREATE VIEW public_url.email23 AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197071/email.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	email_password_recovery_code	CREATE VIEW public_url.email_password_recovery_code AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197091/email-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	gold_vs_bitcoin	CREATE VIEW public_url.gold_vs_bitcoin AS SELECT * FROM "https://corsproxy.io/?https://www.timestored.com/data/sample/pq/gold_vs_bitcoin.parquet";	NONE	NO	NO	NO	NO	NO
memory	public_url	i5_mb	CREATE VIEW public_url.i5_mb AS SELECT * FROM "https://microsoftedge.github.io/Demos/json-dummy-data/5MB.json";	NONE	NO	NO	NO	NO	NO
memory	public_url	iris	CREATE VIEW public_url.iris AS SELECT * FROM "https://corsproxy.io/?https://www.timestored.com/data/sample/iris.parquet";	NONE	NO	NO	NO	NO	NO
memory	public_url	json5_mb	CREATE VIEW public_url.json5_mb AS SELECT * FROM "https://microsoftedge.github.io/Demos/json-dummy-data/5MB.json";	NONE	NO	NO	NO	NO	NO
memory	public_url	municipios	CREATE VIEW public_url.municipios AS SELECT * FROM "https://corsproxy.io/?url=https://github.com/vmisq/city-quiz/raw/refs/heads/main/data/municipios.json";	NONE	NO	NO	NO	NO	NO
memory	public_url	search_trends	CREATE VIEW public_url.search_trends AS SELECT * FROM "https://corsproxy.io/?https://www.timestored.com/data/sample/pq/search_trends.parquet";	NONE	NO	NO	NO	NO	NO
memory	public_url	table	CREATE VIEW public_url."table" AS SELECT * FROM "https://corsproxy.io/?https://www.timestored.com/data/sample/table.parquet";	NONE	NO	NO	NO	NO	NO
memory	public_url	taq	CREATE VIEW public_url.taq AS SELECT * FROM "https://corsproxy.io/?https://www.timestored.com/data/sample/pq/taq.parquet";	NONE	NO	NO	NO	NO	NO
memory	public_url	titanic	CREATE VIEW public_url.titanic AS SELECT * FROM "https://corsproxy.io/?https://www.timestored.com/data/sample/titanic.parquet";	NONE	NO	NO	NO	NO	NO
memory	public_url	userdata	CREATE VIEW public_url.userdata AS SELECT * FROM "https://corsproxy.io/?https://www.timestored.com/data/sample/userdata.parquet";	NONE	NO	NO	NO	NO	NO
memory	public_url	username	CREATE VIEW public_url.username AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197031/username.csv";	NONE	NO	NO	NO	NO	NO
memory	public_url	username_password_recovery_code	CREATE VIEW public_url.username_password_recovery_code AS SELECT * FROM "https://support.staffbase.com/hc/en-us/article_attachments/360009197011/username-password-recovery-code.csv";	NONE	NO	NO	NO	NO	NO
memory	q	q	CREATE VIEW q.q AS SELECT * FROM information_schema."views";	NONE	NO	NO	NO	NO	NO
memory	q	q2	CREATE VIEW q.q2 AS SELECT * FROM q.q;	NONE	NO	NO	NO	NO	NO
memory	q	q3	CREATE VIEW q.q3 AS SELECT * FROM information_schema."views";	NONE	NO	NO	NO	NO	NO
memory	q	t2	CREATE VIEW q.t2 AS SELECT * FROM information_schema."views";	NONE	NO	NO	NO	NO	NO
memory	q	t3	CREATE VIEW q.t3 AS SELECT * FROM information_schema."views";	NONE	NO	NO	NO	NO	NO
memory	q	t4	CREATE VIEW q.t4 AS SELECT * FROM information_schema."views";	NONE	NO	NO	NO	NO	NO
memory	q	teste	CREATE VIEW q.teste AS SELECT * FROM public_url.aabbcc11;	NONE	NO	NO	NO	NO	NO
memory	q	teste2	CREATE VIEW q.teste2 AS SELECT * FROM public_url.aabbcc11;	NONE	NO	NO	NO	NO	NO
memory	uploaded	public_url	CREATE VIEW uploaded.public_url AS SELECT * FROM "public-url.csv";	NONE	NO	NO	NO	NO	NO
memory	uploaded	userdata1	CREATE VIEW uploaded.userdata1 AS SELECT * FROM "userdata1.parquet";	NONE	NO	NO	NO	NO	NO
system	information_schema	character_sets	CREATE TEMPORARY VIEW information_schema.character_sets AS SELECT CAST(NULL AS VARCHAR) AS character_set_catalog, CAST(NULL AS VARCHAR) AS character_set_schema, 'UTF8' AS character_set_name, 'UCS' AS character_repertoire, 'UTF8' AS form_of_use, current_database() AS default_collate_catalog, 'pg_catalog' AS default_collate_schema, 'ucs_basic' AS default_collate_name;	NONE	NO	NO	NO	NO	NO
system	information_schema	check_constraints	CREATE TEMPORARY VIEW information_schema.check_constraints AS SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, CASE  WHEN ((constraint_type = 'NOT NULL')) THEN ((column_name || ' IS NOT NULL')) ELSE constraint_text END AS check_clause FROM (SELECT dc.*, unnest(dc.constraint_column_names) AS column_name FROM duckdb_constraints() AS dc WHERE (constraint_type IN ('CHECK', 'NOT NULL')));	NONE	NO	NO	NO	NO	NO
system	information_schema	columns	CREATE TEMPORARY VIEW information_schema."columns" AS SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, column_name, column_index AS ordinal_position, column_default, CASE  WHEN (is_nullable) THEN ('YES') ELSE 'NO' END AS is_nullable, data_type, character_maximum_length, CAST(NULL AS INTEGER) AS character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, CAST(NULL AS INTEGER) AS datetime_precision, CAST(NULL AS VARCHAR) AS interval_type, CAST(NULL AS INTEGER) AS interval_precision, CAST(NULL AS VARCHAR) AS character_set_catalog, CAST(NULL AS VARCHAR) AS character_set_schema, CAST(NULL AS VARCHAR) AS character_set_name, CAST(NULL AS VARCHAR) AS collation_catalog, CAST(NULL AS VARCHAR) AS collation_schema, CAST(NULL AS VARCHAR) AS collation_name, CAST(NULL AS VARCHAR) AS domain_catalog, CAST(NULL AS VARCHAR) AS domain_schema, CAST(NULL AS VARCHAR) AS domain_name, CAST(NULL AS VARCHAR) AS udt_catalog, CAST(NULL AS VARCHAR) AS udt_schema, CAST(NULL AS VARCHAR) AS udt_name, CAST(NULL AS VARCHAR) AS scope_catalog, CAST(NULL AS VARCHAR) AS scope_schema, CAST(NULL AS VARCHAR) AS scope_name, CAST(NULL AS BIGINT) AS maximum_cardinality, CAST(NULL AS VARCHAR) AS dtd_identifier, CAST(NULL AS BOOLEAN) AS is_self_referencing, CAST(NULL AS BOOLEAN) AS is_identity, CAST(NULL AS VARCHAR) AS identity_generation, CAST(NULL AS VARCHAR) AS identity_start, CAST(NULL AS VARCHAR) AS identity_increment, CAST(NULL AS VARCHAR) AS identity_maximum, CAST(NULL AS VARCHAR) AS identity_minimum, CAST(NULL AS BOOLEAN) AS identity_cycle, CAST(NULL AS VARCHAR) AS is_generated, CAST(NULL AS VARCHAR) AS generation_expression, CAST(NULL AS BOOLEAN) AS is_updatable, "comment" AS COLUMN_COMMENT FROM duckdb_columns;	NONE	NO	NO	NO	NO	NO
system	information_schema	constraint_column_usage	CREATE TEMPORARY VIEW information_schema.constraint_column_usage AS SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, column_name, database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, constraint_type, constraint_text FROM (SELECT dc.*, unnest(dc.constraint_column_names) AS column_name FROM duckdb_constraints() AS dc WHERE (constraint_type NOT IN ('NOT NULL')));	NONE	NO	NO	NO	NO	NO
system	information_schema	constraint_table_usage	CREATE TEMPORARY VIEW information_schema.constraint_table_usage AS SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, constraint_type FROM duckdb_constraints() WHERE (constraint_type NOT IN ('NOT NULL'));	NONE	NO	NO	NO	NO	NO
system	information_schema	key_column_usage	CREATE TEMPORARY VIEW information_schema.key_column_usage AS SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, database_name AS table_catalog, schema_name AS table_schema, table_name, unnest(constraint_column_names) AS column_name, unnest(generate_series(1, len(constraint_column_names))) AS ordinal_position, CASE  WHEN ((constraint_type = 'FOREIGN KEY')) THEN (1) ELSE NULL END AS position_in_unique_constraint FROM duckdb_constraints() WHERE ((constraint_type = 'FOREIGN KEY') OR (constraint_type = 'PRIMARY KEY') OR (constraint_type = 'UNIQUE'));	NONE	NO	NO	NO	NO	NO
system	information_schema	referential_constraints	CREATE TEMPORARY VIEW information_schema.referential_constraints AS SELECT f.database_name AS constraint_catalog, f.schema_name AS constraint_schema, f.constraint_name AS constraint_name, c.database_name AS unique_constraint_catalog, c.schema_name AS unique_constraint_schema, c.constraint_name AS unique_constraint_name, 'NONE' AS match_option, 'NO ACTION' AS update_rule, 'NO ACTION' AS delete_rule FROM duckdb_constraints() AS c , duckdb_constraints() AS f WHERE ((f.constraint_type = 'FOREIGN KEY') AND ((c.constraint_type = 'UNIQUE') OR (c.constraint_type = 'PRIMARY KEY')) AND (f.database_oid = c.database_oid) AND (f.schema_oid = c.schema_oid) AND (lower(f.referenced_table) = lower(c.table_name)) AND (main.list_apply(f.referenced_column_names, (lambda x: lower(x))) = main.list_apply(c.constraint_column_names, (lambda x: lower(x)))));	NONE	NO	NO	NO	NO	NO
system	information_schema	schemata	CREATE TEMPORARY VIEW information_schema.schemata AS SELECT database_name AS catalog_name, schema_name, 'duckdb' AS schema_owner, CAST(NULL AS VARCHAR) AS default_character_set_catalog, CAST(NULL AS VARCHAR) AS default_character_set_schema, CAST(NULL AS VARCHAR) AS default_character_set_name, "sql" AS sql_path FROM duckdb_schemas();	NONE	NO	NO	NO	NO	NO
system	information_schema	tables	CREATE TEMPORARY VIEW information_schema."tables" AS (SELECT database_name AS table_catalog, schema_name AS table_schema, table_name, CASE  WHEN ("temporary") THEN ('LOCAL TEMPORARY') ELSE 'BASE TABLE' END AS table_type, CAST(NULL AS VARCHAR) AS self_referencing_column_name, CAST(NULL AS VARCHAR) AS reference_generation, CAST(NULL AS VARCHAR) AS user_defined_type_catalog, CAST(NULL AS VARCHAR) AS user_defined_type_schema, CAST(NULL AS VARCHAR) AS user_defined_type_name, 'YES' AS is_insertable_into, 'NO' AS is_typed, CASE  WHEN ("temporary") THEN ('PRESERVE') ELSE NULL END AS commit_action, "comment" AS TABLE_COMMENT FROM duckdb_tables()) UNION ALL (SELECT database_name AS table_catalog, schema_name AS table_schema, view_name AS table_name, 'VIEW' AS table_type, NULL AS self_referencing_column_name, NULL AS reference_generation, NULL AS user_defined_type_catalog, NULL AS user_defined_type_schema, NULL AS user_defined_type_name, 'NO' AS is_insertable_into, 'NO' AS is_typed, NULL AS commit_action, "comment" AS TABLE_COMMENT FROM duckdb_views);	NONE	NO	NO	NO	NO	NO
system	information_schema	table_constraints	CREATE TEMPORARY VIEW information_schema.table_constraints AS SELECT database_name AS constraint_catalog, schema_name AS constraint_schema, constraint_name, database_name AS table_catalog, schema_name AS table_schema, table_name, CASE  WHEN ((constraint_type = 'NOT NULL')) THEN ('CHECK') ELSE constraint_type END AS constraint_type, 'NO' AS is_deferrable, 'NO' AS initially_deferred, 'YES' AS enforced, 'YES' AS nulls_distinct FROM duckdb_constraints() WHERE ((constraint_type = 'PRIMARY KEY') OR (constraint_type = 'FOREIGN KEY') OR (constraint_type = 'UNIQUE') OR (constraint_type = 'CHECK') OR (constraint_type = 'NOT NULL'));	NONE	NO	NO	NO	NO	NO
system	information_schema	views	CREATE TEMPORARY VIEW information_schema."views" AS SELECT database_name AS table_catalog, schema_name AS table_schema, view_name AS table_name, "sql" AS view_definition, 'NONE' AS check_option, 'NO' AS is_updatable, 'NO' AS is_insertable_into, 'NO' AS is_trigger_updatable, 'NO' AS is_trigger_deletable, 'NO' AS is_trigger_insertable_into FROM duckdb_views();	NONE	NO	NO	NO	NO	NO
system	main	duckdb_columns	CREATE TEMPORARY VIEW duckdb_columns AS SELECT * FROM duckdb_columns() WHERE (NOT internal);	NONE	NO	NO	NO	NO	NO
system	main	duckdb_constraints	CREATE TEMPORARY VIEW duckdb_constraints AS SELECT * FROM duckdb_constraints();	NONE	NO	NO	NO	NO	NO
system	main	duckdb_databases	CREATE TEMPORARY VIEW duckdb_databases AS SELECT * FROM duckdb_databases() WHERE (NOT internal);	NONE	NO	NO	NO	NO	NO
system	main	duckdb_indexes	CREATE TEMPORARY VIEW duckdb_indexes AS SELECT * FROM duckdb_indexes();	NONE	NO	NO	NO	NO	NO
system	main	duckdb_logs	CREATE TEMPORARY VIEW duckdb_logs AS SELECT * EXCLUDE (c.context_id, l.context_id) FROM duckdb_logs() AS l INNER JOIN duckdb_log_contexts() AS c ON ((l.context_id = c.context_id)) ORDER BY "timestamp";	NONE	NO	NO	NO	NO	NO
system	main	duckdb_schemas	CREATE TEMPORARY VIEW duckdb_schemas AS SELECT * FROM duckdb_schemas() WHERE (NOT internal);	NONE	NO	NO	NO	NO	NO
system	main	duckdb_tables	CREATE TEMPORARY VIEW duckdb_tables AS SELECT * FROM duckdb_tables() WHERE (NOT internal);	NONE	NO	NO	NO	NO	NO
system	main	duckdb_types	CREATE TEMPORARY VIEW duckdb_types AS SELECT * FROM duckdb_types();	NONE	NO	NO	NO	NO	NO
system	main	duckdb_views	CREATE TEMPORARY VIEW duckdb_views AS SELECT * FROM duckdb_views() WHERE (NOT internal);	NONE	NO	NO	NO	NO	NO
system	main	pragma_database_list	CREATE TEMPORARY VIEW pragma_database_list AS SELECT database_oid AS seq, database_name AS "name", path AS file FROM duckdb_databases() WHERE (NOT internal) ORDER BY 1;	NONE	NO	NO	NO	NO	NO
system	main	sqlite_master	CREATE TEMPORARY VIEW sqlite_master AS ((SELECT 'table' AS "type", table_name AS "name", table_name AS tbl_name, 0 AS rootpage, "sql" FROM duckdb_tables) UNION ALL (SELECT 'view' AS "type", view_name AS "name", view_name AS tbl_name, 0 AS rootpage, "sql" FROM duckdb_views)) UNION ALL (SELECT 'index' AS "type", index_name AS "name", table_name AS tbl_name, 0 AS rootpage, "sql" FROM duckdb_indexes);	NONE	NO	NO	NO	NO	NO
system	main	sqlite_schema	CREATE TEMPORARY VIEW sqlite_schema AS SELECT * FROM sqlite_master;	NONE	NO	NO	NO	NO	NO
system	main	sqlite_temp_master	CREATE TEMPORARY VIEW sqlite_temp_master AS SELECT * FROM sqlite_master;	NONE	NO	NO	NO	NO	NO
system	main	sqlite_temp_schema	CREATE TEMPORARY VIEW sqlite_temp_schema AS SELECT * FROM sqlite_master;	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_am	CREATE TEMPORARY VIEW pg_catalog.pg_am AS SELECT 0 AS oid, 'art' AS amname, NULL AS amhandler, 'i' AS amtype;	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_attrdef	CREATE TEMPORARY VIEW pg_catalog.pg_attrdef AS SELECT column_index AS oid, table_oid AS adrelid, column_index AS adnum, column_default AS adbin FROM duckdb_columns() WHERE (column_default IS NOT NULL);	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_attribute	CREATE TEMPORARY VIEW pg_catalog.pg_attribute AS SELECT table_oid AS attrelid, column_name AS attname, data_type_id AS atttypid, 0 AS attstattarget, NULL AS attlen, column_index AS attnum, 0 AS attndims, -1 AS attcacheoff, CASE  WHEN ((data_type ~~* '%decimal%')) THEN (((numeric_precision * 1000) + numeric_scale)) ELSE -1 END AS atttypmod, CAST('f' AS BOOLEAN) AS attbyval, NULL AS attstorage, NULL AS attalign, (NOT is_nullable) AS attnotnull, (column_default IS NOT NULL) AS atthasdef, CAST('f' AS BOOLEAN) AS atthasmissing, '' AS attidentity, '' AS attgenerated, CAST('f' AS BOOLEAN) AS attisdropped, CAST('t' AS BOOLEAN) AS attislocal, 0 AS attinhcount, 0 AS attcollation, NULL AS attcompression, NULL AS attacl, NULL AS attoptions, NULL AS attfdwoptions, NULL AS attmissingval FROM duckdb_columns();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_class	CREATE TEMPORARY VIEW pg_catalog.pg_class AS (((SELECT table_oid AS oid, table_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, CAST(estimated_size AS FLOAT) AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, (index_count > 0) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN ('t') ELSE 'p' END AS relpersistence, 'r' AS relkind, column_count AS relnatts, check_constraint_count AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, has_primary_key AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_tables()) UNION ALL (SELECT view_oid AS oid, view_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST('f' AS BOOLEAN) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN ('t') ELSE 'p' END AS relpersistence, 'v' AS relkind, column_count AS relnatts, 0 AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, CAST('f' AS BOOLEAN) AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_views())) UNION ALL (SELECT sequence_oid AS oid, sequence_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST('f' AS BOOLEAN) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN ('t') ELSE 'p' END AS relpersistence, 'S' AS relkind, 0 AS relnatts, 0 AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, CAST('f' AS BOOLEAN) AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_sequences())) UNION ALL (SELECT index_oid AS oid, index_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST('f' AS BOOLEAN) AS relhasindex, CAST('f' AS BOOLEAN) AS relisshared, 't' AS relpersistence, 'i' AS relkind, NULL AS relnatts, 0 AS relchecks, CAST('f' AS BOOLEAN) AS relhasoids, CAST('f' AS BOOLEAN) AS relhaspkey, CAST('f' AS BOOLEAN) AS relhasrules, CAST('f' AS BOOLEAN) AS relhastriggers, CAST('f' AS BOOLEAN) AS relhassubclass, CAST('f' AS BOOLEAN) AS relrowsecurity, CAST('t' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST('f' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_indexes());	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_constraint	CREATE TEMPORARY VIEW pg_catalog.pg_constraint AS SELECT ((table_oid * 1000000) + constraint_index) AS oid, constraint_text AS conname, schema_oid AS connamespace, CASE  WHEN ((constraint_type = 'CHECK')) THEN ('c') WHEN ((constraint_type = 'UNIQUE')) THEN ('u') WHEN ((constraint_type = 'PRIMARY KEY')) THEN ('p') WHEN ((constraint_type = 'FOREIGN KEY')) THEN ('f') ELSE 'x' END AS contype, CAST('f' AS BOOLEAN) AS condeferrable, CAST('f' AS BOOLEAN) AS condeferred, CAST('t' AS BOOLEAN) AS convalidated, table_oid AS conrelid, 0 AS contypid, 0 AS conindid, 0 AS conparentid, 0 AS confrelid, NULL AS confupdtype, NULL AS confdeltype, NULL AS confmatchtype, CAST('t' AS BOOLEAN) AS conislocal, 0 AS coninhcount, CAST('f' AS BOOLEAN) AS connoinherit, constraint_column_indexes AS conkey, NULL AS confkey, NULL AS conpfeqop, NULL AS conppeqop, NULL AS conffeqop, NULL AS conexclop, expression AS conbin FROM duckdb_constraints();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_database	CREATE TEMPORARY VIEW pg_catalog.pg_database AS SELECT database_oid AS oid, database_name AS datname FROM duckdb_databases();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_depend	CREATE TEMPORARY VIEW pg_catalog.pg_depend AS SELECT * FROM duckdb_dependencies();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_description	CREATE TEMPORARY VIEW pg_catalog.pg_description AS ((((((SELECT table_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_tables() WHERE (NOT internal)) UNION ALL (SELECT table_oid AS objoid, database_oid AS classoid, column_index AS objsubid, "comment" AS description FROM duckdb_columns() WHERE (NOT internal))) UNION ALL (SELECT view_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_views() WHERE (NOT internal))) UNION ALL (SELECT index_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_indexes)) UNION ALL (SELECT sequence_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_sequences())) UNION ALL (SELECT type_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_types() WHERE (NOT internal))) UNION ALL (SELECT function_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_functions() WHERE (NOT internal));	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_enum	CREATE TEMPORARY VIEW pg_catalog.pg_enum AS SELECT NULL AS oid, a.type_oid AS enumtypid, list_position(b.labels, a.elabel) AS enumsortorder, a.elabel AS enumlabel FROM (SELECT unnest(labels) AS elabel, type_oid FROM duckdb_types() WHERE (logical_type = 'ENUM')) AS a INNER JOIN duckdb_types() AS b ON ((a.type_oid = b.type_oid));	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_index	CREATE TEMPORARY VIEW pg_catalog.pg_index AS SELECT index_oid AS indexrelid, table_oid AS indrelid, 0 AS indnatts, 0 AS indnkeyatts, is_unique AS indisunique, is_primary AS indisprimary, CAST('f' AS BOOLEAN) AS indisexclusion, CAST('t' AS BOOLEAN) AS indimmediate, CAST('f' AS BOOLEAN) AS indisclustered, CAST('t' AS BOOLEAN) AS indisvalid, CAST('f' AS BOOLEAN) AS indcheckxmin, CAST('t' AS BOOLEAN) AS indisready, CAST('t' AS BOOLEAN) AS indislive, CAST('f' AS BOOLEAN) AS indisreplident, CAST(NULL AS INTEGER[]) AS indkey, CAST(NULL AS BIGINT[]) AS indcollation, CAST(NULL AS BIGINT[]) AS indclass, CAST(NULL AS INTEGER[]) AS indoption, expressions AS indexprs, NULL AS indpred FROM duckdb_indexes();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_indexes	CREATE TEMPORARY VIEW pg_catalog.pg_indexes AS SELECT schema_name AS schemaname, table_name AS tablename, index_name AS indexname, NULL AS "tablespace", "sql" AS indexdef FROM duckdb_indexes();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_namespace	CREATE TEMPORARY VIEW pg_catalog.pg_namespace AS SELECT oid, schema_name AS nspname, 0 AS nspowner, NULL AS nspacl FROM duckdb_schemas() WHERE (database_name = current_database());	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_prepared_statements	CREATE TEMPORARY VIEW pg_catalog.pg_prepared_statements AS SELECT "name", "statement", NULL AS prepare_time, parameter_types, result_types, NULL AS from_sql, NULL AS generic_plans, NULL AS custom_plans FROM duckdb_prepared_statements();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_proc	CREATE TEMPORARY VIEW pg_catalog.pg_proc AS SELECT f.function_oid AS oid, function_name AS proname, s.oid AS pronamespace, NULL AS proowner, NULL AS prolang, 0 AS procost, 0 AS prorows, varargs AS provariadic, 0 AS prosupport, CASE  WHEN ((function_type = 'aggregate')) THEN ('a') ELSE 'f' END AS prokind, CAST('f' AS BOOLEAN) AS prosecdef, CAST('f' AS BOOLEAN) AS proleakproof, CAST('f' AS BOOLEAN) AS proisstrict, (function_type = 'table') AS proretset, CASE  WHEN ((stability = 'CONSISTENT')) THEN ('i') WHEN ((stability = 'CONSISTENT_WITHIN_QUERY')) THEN ('s') WHEN ((stability = 'VOLATILE')) THEN ('v') ELSE NULL END AS provolatile, 'u' AS proparallel, length(parameters) AS pronargs, 0 AS pronargdefaults, return_type AS prorettype, parameter_types AS proargtypes, NULL AS proallargtypes, NULL AS proargmodes, parameters AS proargnames, NULL AS proargdefaults, NULL AS protrftypes, NULL AS prosrc, NULL AS probin, macro_definition AS prosqlbody, NULL AS proconfig, NULL AS proacl, (function_type = 'aggregate') AS proisagg FROM duckdb_functions() AS f LEFT JOIN duckdb_schemas() AS s USING (database_name, schema_name);	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_sequence	CREATE TEMPORARY VIEW pg_catalog.pg_sequence AS SELECT sequence_oid AS seqrelid, 0 AS seqtypid, start_value AS seqstart, increment_by AS seqincrement, max_value AS seqmax, min_value AS seqmin, 0 AS seqcache, "cycle" AS seqcycle FROM duckdb_sequences();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_sequences	CREATE TEMPORARY VIEW pg_catalog.pg_sequences AS SELECT schema_name AS schemaname, sequence_name AS sequencename, 'duckdb' AS sequenceowner, 0 AS data_type, start_value, min_value, max_value, increment_by, "cycle", 0 AS cache_size, last_value FROM duckdb_sequences();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_settings	CREATE TEMPORARY VIEW pg_catalog.pg_settings AS SELECT "name", "value" AS setting, description AS short_desc, CASE  WHEN ((input_type = 'VARCHAR')) THEN ('string') WHEN ((input_type = 'BOOLEAN')) THEN ('bool') WHEN ((input_type IN ('BIGINT', 'UBIGINT'))) THEN ('integer') ELSE input_type END AS vartype FROM duckdb_settings();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_tables	CREATE TEMPORARY VIEW pg_catalog.pg_tables AS SELECT schema_name AS schemaname, table_name AS tablename, 'duckdb' AS tableowner, NULL AS "tablespace", (index_count > 0) AS hasindexes, CAST('f' AS BOOLEAN) AS hasrules, CAST('f' AS BOOLEAN) AS hastriggers FROM duckdb_tables();	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_tablespace	CREATE TEMPORARY VIEW pg_catalog.pg_tablespace AS SELECT 0 AS oid, 'pg_default' AS spcname, 0 AS spcowner, NULL AS spcacl, NULL AS spcoptions;	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_type	CREATE TEMPORARY VIEW pg_catalog.pg_type AS SELECT CASE  WHEN ((type_oid IS NULL)) THEN (NULL) WHEN (((logical_type = 'ENUM') AND (type_name != 'enum'))) THEN (type_oid) ELSE map_to_pg_oid(type_name) END AS oid, format_pg_type(logical_type, type_name) AS typname, schema_oid AS typnamespace, 0 AS typowner, type_size AS typlen, CAST('f' AS BOOLEAN) AS typbyval, CASE  WHEN ((logical_type = 'ENUM')) THEN ('e') ELSE 'b' END AS typtype, CASE  WHEN ((type_category = 'NUMERIC')) THEN ('N') WHEN ((type_category = 'STRING')) THEN ('S') WHEN ((type_category = 'DATETIME')) THEN ('D') WHEN ((type_category = 'BOOLEAN')) THEN ('B') WHEN ((type_category = 'COMPOSITE')) THEN ('C') WHEN ((type_category = 'USER')) THEN ('U') ELSE 'X' END AS typcategory, CAST('f' AS BOOLEAN) AS typispreferred, CAST('t' AS BOOLEAN) AS typisdefined, NULL AS typdelim, NULL AS typrelid, NULL AS typsubscript, NULL AS typelem, NULL AS typarray, NULL AS typinput, NULL AS typoutput, NULL AS typreceive, NULL AS typsend, NULL AS typmodin, NULL AS typmodout, NULL AS typanalyze, 'd' AS typalign, 'p' AS typstorage, NULL AS typnotnull, NULL AS typbasetype, NULL AS typtypmod, NULL AS typndims, NULL AS typcollation, NULL AS typdefaultbin, NULL AS typdefault, NULL AS typacl FROM duckdb_types() WHERE (type_oid IS NOT NULL);	NONE	NO	NO	NO	NO	NO
system	pg_catalog	pg_views	CREATE TEMPORARY VIEW pg_catalog.pg_views AS SELECT schema_name AS schemaname, view_name AS viewname, 'duckdb' AS viewowner, "sql" AS definition FROM duckdb_views();	NONE	NO	NO	NO	NO	NO